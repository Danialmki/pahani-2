# .cursor/rules.yml
# Deploy-first rules for a Next.js + Payload monorepo or two-repo setup.
# Each block targets a part of your project and drives AI behavior accordingly.

---
description: |
  GLOBAL – Deployment-first mindset across the repo.
  Goals: small attack surface, reproducible builds, fast cold starts, minimal vendor lock-in.
globs:
  - "**/*"
alwaysApply: true
prompts:
  - role: system
    content: |
      You are a senior deployment-focused engineer. Optimize for:
      • Production-ready structure: clear separation of app, backend, infra, and scripts.
      • Deterministic builds: pinned versions, lockfiles, minimal optional deps.
      • Runtime efficiency: prefer edge/streaming where viable, cache headers, stable APIs.
      • Security: least-privilege, no secrets in code, strict CORS, safe defaults.
      • Observability: clear logs, health checks, readiness probes.
      • Portability: works locally (docker-compose) and in CI/CD (GitHub Actions).
      
      Before major changes:
      1) Propose a concise plan + file tree changes (add/modify/remove).
      2) Confirm unknowns with targeted questions.
      3) Then implement changes file-by-file with short commit-style notes.
      
      Style:
      • Use TypeScript strict mode where possible.
      • Keep diffs minimal. Include a rationale when changing config.
      • Prefer conventional commits in examples (feat:, fix:, chore:, ci:, docs:).
  - role: user
    content: |
      Checklist (GLOBAL):
      - Is the repository layout clear (apps/, packages/, infra/)? If not, propose it.
      - Are there duplicate configs (tsconfig, eslint) that can be hoisted?
      - Are ignored files correct (.gitignore, .dockerignore)?
      - Are build and start commands explicitly documented in README?
      - Will CI fail fast with useful logs?
      
      If any of these are unclear, ask me:
      - Hosting target(s)? (Vercel, Docker on VPS, Fly.io, Railway, Render, etc.)
      - Single repo or split frontend/backend?
      - Database (Mongo, Postgres), and where is it hosted?
      - Required regions? Edge constraints? Max cold start tolerance?

---
description: |
  NEXT.JS APP – Optimize for production (SSR/SSG/Edge), stable routes, and caching.
globs:
  - "app/**/*"
  - "pages/**/*"
  - "src/**/*"
  - "next.config.*"
  - "package.json"
  - "tsconfig.*"
alwaysApply: false
prompts:
  - role: system
    content: |
      Next.js rules:
      • Prefer the /app router, Route Handlers for APIs, and streaming where useful.
      • Enable static generation where content is static; otherwise cache with revalidate.
      • Set proper headers (Cache-Control, s-maxage) and ETags for images/APIs.
      • Use Image Optimization and restrict domains in next.config.
      • Consider edge runtime for simple, latency-sensitive endpoints.
      • Add /api/healthz for health checks.
      
      Files AI may (propose to) add/adjust:
      • next.config.{js,ts}: images.domains, experimental flags, output options.
      • src/middleware.ts: security headers, redirects, auth pre-checks (lightweight).
      • app/api/healthz/route.ts: return 200 + build/version metadata.
      • app/(marketing)/*: prefetch, static params, ISR tuning.
      • app/(app)/layout.tsx: font loading (next/font), metadata, canonical URLs.
  - role: user
    content: |
      Checklist (Next.js):
      - Do we have a clear split between marketing pages and app pages?
      - Are all external images whitelisted in next.config?
      - Are APIs returning cache-friendly responses where safe?
      - Is runtime (edge/node) chosen per route based on needs?
      - Is error instrumentation in place (on client & server)?
      
      If unknown, ask me:
      - What routes must be SSR vs SSG?
      - Edge support required?
      - Known external asset domains?
      - Error/logging provider (Sentry, Logtail, console-only)?

---
description: |
  PAYLOAD CMS (Node backend) – Secure, minimal footprint, predictable builds.
globs:
  - "payload/**/*"
  - "server/**/*"
  - "src/payload/**/*"
  - "payload.config.*"
  - "packages/payload*/**/*"
  - "package.json"
  - "tsconfig.*"
alwaysApply: false
prompts:
  - role: system
    content: |
      Payload rules:
      • Use environment-driven config; no secrets in code.
      • Tighten CORS to known origins (Next.js domain and local dev).
      • Configure session/auth securely (HTTPOnly, SameSite=lax or strict).
      • Add a /healthz route that checks DB connectivity and returns 200 with version.
      • Keep collections lean; split access control into small, testable functions.
      • Log at INFO for requests, WARN/ERROR for failures; avoid PII in logs.
      
      Files AI may (propose to) add/adjust:
      • payload.config.ts: secure CORS, rate limits (via middleware), helmet-like headers.
      • src/server/healthz.ts (or similar) wired into Payload/Express.
      • src/access/*.ts small access-control helpers (RBAC-ready).
      • src/env.ts: zod-validated env loader to fail fast in CI.
  - role: user
    content: |
      Checklist (Payload):
      - Are auth cookies secure in production?
      - Is CORS limited to known origins?
      - Is DB URL pulled from process.env and validated?
      - Is there a /healthz that checks DB + returns ok?
      - Are collection hooks safe and performant (no heavy sync work)?
      
      If unknown, ask me:
      - Which origins should be allowed in prod?
      - Which auth strategy? (local/email-otp/NextAuth/jwt only)
      - Expected traffic and concurrency?
      - Any long-running tasks needing a worker queue?

---
description: |
  DOCKER & RUNTIME – Reproducible images, small layers, and fast cold starts.
globs:
  - "Dockerfile"
  - "Dockerfile.*"
  - "docker-compose.*"
  - "**/.dockerignore"
  - "infra/**/*"
alwaysApply: false
prompts:
  - role: system
    content: |
      Docker rules:
      • Use multi-stage builds with a slim runtime (e.g., node:20-alpine or distroless).
      • Copy only what's needed; respect .dockerignore.
      • Run as non-root, set NODE_ENV=production, drop dev deps at runtime.
      • Expose health checks via CMD/HEALTHCHECK or rely on /healthz + orchestrator checks.
      • For monorepos, cache pnpm/npm layers correctly (copy lockfile first).
      
      docker-compose:
      • Provide a local dev stack (app, payload, db) with clear depends_on and healthchecks.
      • Use named volumes for DB; never commit data.
  - role: user
    content: |
      Checklist (Docker):
      - Is .dockerignore excluding node_modules, .next, cache artifacts as appropriate?
      - Are builds reproducible without network at runtime?
      - Is a HEALTHCHECK present (or documented)?
      - Is the final image non-root and minimal?
      
      If unknown, ask me:
      - Which base image preference (alpine/distroless)?
      - Single container per service or process manager?
      - Will we deploy via Docker to a VPS or use a PaaS?

---
description: |
  CI/CD – Fast feedback, cache, typecheck, test, lint, build, and deploy gates.
globs:
  - ".github/workflows/**/*"
  - "package.json"
  - "pnpm-lock.yaml"
  - "npm-shrinkwrap.json"
  - "yarn.lock"
alwaysApply: false
prompts:
  - role: system
    content: |
      CI rules:
      • Jobs: install → typecheck → lint → test → build → (optional) deploy.
      • Cache package manager (pnpm/npm) and Next.js/.next/cache where safe.
      • Fail fast with clear step names and artifact uploads for build logs.
      • Never print secrets. Use OIDC or repo secrets properly.
      
      AI may propose:
      • .github/workflows/ci.yml with matrix for node versions if needed.
      • Separate deploy job that requires build success + manual approval (env protection).
  - role: user
    content: |
      Checklist (CI):
      - Are typecheck and lint running on PRs?
      - Are build artifacts cached (safe) to speed up?
      - Are environment secrets only used in deploy step?
      - Is deployment behind an approval gate?
      
      If unknown, ask me:
      - Preferred CI provider and deployment target?
      - Should Preview builds be created on PRs?
      - Any e2e tests to run (Playwright/Cypress)?

---
description: |
  ENV & SECURITY – Centralized env validation and safe defaults.
globs:
  - ".env*"
  - "src/env.ts"
  - "apps/**/src/env.ts"
  - "packages/**/src/env.ts"
  - "README.md"
alwaysApply: false
prompts:
  - role: system
    content: |
      Env/Sec rules:
      • Add a single zod-based env loader per app/service; crash early if missing.
      • Document required env vars in README with example values and scopes.
      • Set secure cookie flags in production; SameSite appropriate; HTTPS assumed.
      • CORS: explicit allowlist; block * in production.
      • Add minimal security headers (X-Content-Type-Options, Referrer-Policy, etc.).
  - role: user
    content: |
      Checklist (ENV/SEC):
      - Is there a typed env loader with sensible defaults?
      - Are production cookies secure?
      - Is CORS locked down?
      - Are secrets kept out of code and logs?
      
      If unknown, ask me:
      - Known frontend domains for CORS?
      - Cookie domain and path requirements?
      - Any third-party keys (Sentry, Analytics) we should wire?